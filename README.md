# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могу включить и выключить отопление.

**Мониторинг температуры:**

- Пользователи могут запросить показания температуры.

### 2. Анализ архитектуры монолитного приложения
1. Архитектура приложения представляет это Монолит. 
2. Язык - Go. Синхронный фреймворк.
3. Для хранения данных пользователей используется СУБД Postgres.  
4. Тип взаимодействия клиент - сервер.

### 3. Определение доменов и границы контекстов

Домены.
1. Включение и выключение отопления.
2. Включение и выключение света.
3. Запирание и отпирание автоматических ворот.
4. Подключение и отключение к камерам наблюдения за домом.

### **4. Проблемы монолитного решения**

На данном этапе развития компании плюсы модульного монолита на мой взгляд перевешивают минусы. Ярким примером удачного 
модульно монолита является instagram (до 2012 года он был монолитом). Так же хочется выделить 
что большинство реальных минусов текущего решения не связанны с монолитной архитектурой как таковой: 
- Скудный функционал, только управлять отоплением в доме и проверять температуру. 
- Для установки нужно вызвать специалиста по подключению системы отопления в доме к текущей версии системы. 
- Всё синхронно. Никаких асинхронных вызовов, реактивного взаимодействия в системе нет. 
- Самостоятельно подключить свой датчик к системе пользователь не может.  

В данном параграфе перечислим минусы данного подхода:
- Монолит масштабируется только весь целиком. 
- Развернуть монолит для локальной разработки труднее чем 1 микросервис.
- Большой пул зависимостей. Зависимости каждого конкретного модуля могу начать конфликтовать с зависимостями других модулей.
- Статистически в монолитах тесты чаще мигают чем в микросервисах.  

Плюсы монолита:
- Легкость реализации транзакций. В микро-сервисной архитектуре не возможно приблизится к ACID транзакциям. 
Там только "повествования" (Saga) и компенсирующие операции.
- Нет межсетевых накладок на вызов 1 сервиса другим. Все вызовы проходят внутри 1 программы. 
- В части случаев отлаживать монолит проще чем микросервисы. Не требуется трейсин: jaeger, span. 
Можно просто включить локально дебагер.

Если вы считаете, что текущее решение не вызывает проблем, аргументируйте свою позицию.

### 5. Визуализация контекста системы — диаграмма С4

[warm_house.puml](diagrams/context/warm_house.puml)

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

[warm_house.puml](diagrams/container/warm_house.puml)Добавьте диаграмму.

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.
[management.puml](diagrams/component/management.puml)
[light.puml](diagrams/component/light.puml)
[heating.puml](diagrams/component/heating.puml)
[gate.puml](diagrams/component/gate.puml)
[camera.puml](diagrams/component/camera.puml)

**Диаграмма кода (Code)**
[management.puml](diagrams/code/management.puml)

# Задание 3. Разработка ER-диаграммы

[er.puml](diagrams/er/er.puml)

# Задание 4. Создание и документирование API

### 1. Тип API

Микросервисы будут иметь обычный REST API - это простой и понятный стиль интерфейса, 
который наша команда программистов точно сможет реализовать. Над микросервисами будет реализована федерация, 
которая позволит различным клиентам (веб, моб. ...) удобно агрегировать данные из разных микросервисов за счёт мутаций 
и запросов. 

### 2. Документация API

[openapi.yml](docs/openapi.yml)

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


# **Задание 6. Разработка MVP**

Необходимо создать новые микросервисы и обеспечить их интеграции с существующим монолитом для плавного перехода к микросервисной архитектуре. 

### **Что нужно сделать**

1. Создайте новые микросервисы для управления телеметрией и устройствами (с простейшей логикой), которые будут интегрированы с существующим монолитным приложением. Каждый микросервис на своем ООП языке.
2. Обеспечьте взаимодействие между микросервисами и монолитом (при желании с помощью брокера сообщений), чтобы постепенно перенести функциональность из монолита в микросервисы. 

В результате у вас должны быть созданы Dockerfiles и docker-compose для запуска микросервисов. 